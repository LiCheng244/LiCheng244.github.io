<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title></title>
      <url>http://www.licheng.date/posts/14785933237379.html</url>
      <content type="html"><![CDATA[<h1 id="你好"><a href="#你好" class="headerlink" title="你好"></a>你好</h1><blockquote>
<p>hdskkas</p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#import <span class="meta-string">"nihao.h"</span></span></div><div class="line">@paddjs</div><div class="line"><span class="built_in">NSString</span> *name;</div></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[iOS开发 - 深入理解控制器与类]]></title>
      <url>http://www.licheng.date/posts/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E6%8E%A7%E5%88%B6%E5%99%A8%E4%B8%8E%E7%B1%BB.html</url>
      <content type="html"><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><blockquote>
<p>ViewController是iOS开发中MVC模式中的C(视图控制器)，ViewController是view的controller，ViewController的职责主要包括管理内部各个view的加载显示和卸载，同时负责与其他ViewController的通信和协调。</p>
</blockquote>
<a id="more"></a>
<p>在IOS中，有两类ViewController:    </p>
<blockquote>
<ul>
<li><p>一类主要用于<b>展示内容</b>，比如<code>UIViewController</code>、<code>UITableViewController</code>等，同时还可以自定义继承自UIViewController的ViewController；</p>
</li>
<li><p>另一类是<b>ViewController容器</b>，<code>UINavigationViewController</code>和<code>UITabBarController</code>等，UINavigationController是以Stack的形式来存储和管理ViewController，UITabBarController是以Array的形式来管理ViewController。</p>
</li>
</ul>
</blockquote>
<p>不管是哪类ViewController,都继承自UIViewController</p>
<hr>
<h3 id="UIViewController-–-gt-生命周期方法"><a href="#UIViewController-–-gt-生命周期方法" class="headerlink" title="UIViewController –&gt; 生命周期方法"></a>UIViewController –&gt; 生命周期方法</h3><h4 id="控制器从创建到销毁方法的执行顺序"><a href="#控制器从创建到销毁方法的执行顺序" class="headerlink" title="控制器从创建到销毁方法的执行顺序"></a>控制器从创建到销毁方法的执行顺序</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">load-&gt;initialize-&gt;init(initWithNibName)—&gt;  </div><div class="line">loadView—&gt;viewDidLoad—&gt;viewWillApper—&gt;viewDidApper—&gt;  </div><div class="line">viewWillDisapper—&gt;viewDidDisapper—&gt;viewWillUnload-&gt;  </div><div class="line">viewDidUnload—&gt;dealloc</div></pre></td></tr></table></figure>
<p>其中<code>viewWillUnload</code>跟<code>viewDidUnLoad</code> 在iOS6以后就过期了.<br>收到<code>low-memory</code>时系统不会释放<code>view</code>，而只是释放<code>controller</code>的<code>resource</code>。</p>
<h4 id="注意点"><a href="#注意点" class="headerlink" title="注意点:"></a>注意点:</h4><ul>
<li><p><code>LoadView:</code>    </p>
<ol>
<li>控制器调用loadView方法创建控制器的view.当控制器的view存在了就不会调用.</li>
<li>不要再LoadView中调用<code>[super loadView]</code>,会影响CPU性能</li>
<li>苹果官方文档:    <ul>
<li><blockquote>
<p>You should never call this method directly. The view controller calls this method when its view property is requested but is currently nil. This method loads or creates a view and assigns it to the view property.</p>
</blockquote>
</li>
</ul>
</li>
</ol>
</li>
<li><p>当系统要展示这个控制器view的时候,会先去view的getter方法中寻找有没有返回view,如果<code>view == nil</code>,系统就会主动去调用这个方法.</p>
</li>
<li><p>控制器的view都是懒加载,当需要展示的时候才会去创建</p>
<ol>
<li>懒加载:重写getter方法</li>
<li>好处:不用管什么时候需要创建,做到要用时再创建</li>
</ol>
</li>
</ul>
<h4 id="view的加载过程"><a href="#view的加载过程" class="headerlink" title="view的加载过程"></a>view的加载过程</h4>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[iOS 短信验证码倒计时按钮的实现]]></title>
      <url>http://www.licheng.date/posts/%E7%9F%AD%E4%BF%A1%E9%AA%8C%E8%AF%81%E7%A0%81%E6%8C%89%E9%92%AE%E6%95%88%E6%9E%9C.html</url>
      <content type="html"><![CDATA[<h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><blockquote>
<p>验证码倒计时按钮的应用是非常普遍的，本文介绍了<strong>IOS实现验证码倒计时功能</strong>，点击获取验证码，进入时间倒计时，感兴趣的小伙伴们可以参考一下:<br><a id="more"></a><br><img src="http://upload-images.jianshu.io/upload_images/1975627-527ddb35df0f0061.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="效果图"></p>
<hr>
<h3 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h3><ul>
<li>创建按钮, 添加点击方法;</li>
<li>用NSTimer定时器, 每秒执行一次, 定时改变Button的title,改变Button的样式, 设置Button不可点击;</li>
<li>若倒计时结束, 定时器关闭, 并改变Button的样式, 可以点击;</li>
</ul>
</blockquote>
<h3 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h3><p>在按钮的点击事件里调用该方法.</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 开启倒计时效果</span></div><div class="line">-(<span class="keyword">void</span>)openCountdown&#123;</div><div class="line"></div><div class="line">    __block <span class="built_in">NSInteger</span> time = <span class="number">59</span>; <span class="comment">//倒计时时间</span></div><div class="line">    </div><div class="line">    <span class="built_in">dispatch_queue_t</span> queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>);</div><div class="line">    dispatch_source_t _timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, <span class="number">0</span>, <span class="number">0</span>, queue);</div><div class="line">    </div><div class="line">    dispatch_source_set_timer(_timer,dispatch_walltime(<span class="literal">NULL</span>, <span class="number">0</span>),<span class="number">1.0</span>*<span class="built_in">NSEC_PER_SEC</span>, <span class="number">0</span>); <span class="comment">//每秒执行</span></div><div class="line">    </div><div class="line">    dispatch_source_set_event_handler(_timer, ^&#123;</div><div class="line">        </div><div class="line">        <span class="keyword">if</span>(time &lt;= <span class="number">0</span>)&#123; <span class="comment">//倒计时结束，关闭</span></div><div class="line">            </div><div class="line">            dispatch_source_cancel(_timer);</div><div class="line">            <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</div><div class="line"></div><div class="line">                <span class="comment">//设置按钮的样式</span></div><div class="line">                [<span class="keyword">self</span>.authCodeBtn setTitle:<span class="string">@"重新发送"</span> forState:<span class="built_in">UIControlStateNormal</span>];</div><div class="line">                [<span class="keyword">self</span>.authCodeBtn setTitleColor:[<span class="built_in">UIColor</span> colorFromHexCode:<span class="string">@"FB8557"</span>] forState:<span class="built_in">UIControlStateNormal</span>];</div><div class="line">                <span class="keyword">self</span>.authCodeBtn.userInteractionEnabled = <span class="literal">YES</span>;</div><div class="line">            &#125;);</div><div class="line"></div><div class="line">        &#125;<span class="keyword">else</span>&#123;</div><div class="line">            </div><div class="line">            <span class="keyword">int</span> seconds = time % <span class="number">60</span>;</div><div class="line">            <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</div><div class="line"></div><div class="line">                <span class="comment">//设置按钮显示读秒效果</span></div><div class="line">                [<span class="keyword">self</span>.authCodeBtn setTitle:[<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"重新发送(%.2d)"</span>, seconds] forState:<span class="built_in">UIControlStateNormal</span>];</div><div class="line">                [<span class="keyword">self</span>.authCodeBtn setTitleColor:[<span class="built_in">UIColor</span> colorFromHexCode:<span class="string">@"979797"</span>] forState:<span class="built_in">UIControlStateNormal</span>];</div><div class="line">                <span class="keyword">self</span>.authCodeBtn.userInteractionEnabled = <span class="literal">NO</span>;</div><div class="line">            &#125;);</div><div class="line">            time--;</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">    dispatch_resume(_timer);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h3><p>我们在创建Button时, 要设置Button的样式:<br>当type为: <code>UIButtonTypeCustom</code>时 , 是读秒的效果.<br>当type为: 其他时,  是一闪一闪的效果.<br><br><br><br></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[iOS开发 MRC 和ARC 混编]]></title>
      <url>http://www.licheng.date/posts/MRC%20%E5%92%8CARC%20%E6%B7%B7%E7%BC%96.html</url>
      <content type="html"><![CDATA[<h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><blockquote>
<p>iOS5.0以后就开始可以使用ARC（ Automatic Reference Counting：自动引用计数）来代替之前的MRC（Manual Reference Counting：人工引用计数）来进行内存管理。使用ARC会减少很多代码和忘了释放对象的苦恼。但是事情都有两面性。使用了ARC之后如果你想复用以前写过的使用MRC的类， 就会出报错。这时候怎么办？方法比较简单， 只需要做下面的一个步骤就可以解决：</p>
</blockquote>
<a id="more"></a>
<h3 id="ARC项目-加入-MRC-文件"><a href="#ARC项目-加入-MRC-文件" class="headerlink" title="ARC项目 : 加入 MRC 文件"></a>ARC项目 : 加入 MRC 文件</h3><p>需要设置:<br>选择target －&gt; build phases －&gt; compile sources －&gt; 单击ARC的文件将<code>compiler flags</code>设置为： <code>-fno-objc-arc</code></p>
<h3 id="MRC项目-加入-ARC-文件"><a href="#MRC项目-加入-ARC-文件" class="headerlink" title="MRC项目 : 加入 ARC 文件"></a>MRC项目 : 加入 ARC 文件</h3><p>需要设置:<br>选择target －&gt; build phases －&gt; compile sources －&gt; 单击ARC的文件将<code>compiler flags</code>设置为： <code>-fobjc-arc</code></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1975627-602a02608d8f497a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="MRC 和 ARC 混编"></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[iOS 数据存储 CoreData的使用]]></title>
      <url>http://www.licheng.date/posts/CoreData%E7%9A%84%E4%BD%BF%E7%94%A8.html</url>
      <content type="html"><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><blockquote>
<p>CoreData 是数据持久化存储的最佳方式.<br>CoreData 是基于 sqlite 的封装, 数据保存到一个数据库文件中(表).<br>iOS5 以后才出现.<br>它提供了对象-关系映射(ORM)的功能, 既能够将oc对象转化成数据保存在sqlite文件中, 也能将保存在数据库中的数据还原成oc对象.<br>数据操作期间, 我们不需要编写任何的sql语句.<br>数据最终的存储类型可以是：SQLite数据库，XML，二进制，内存里，或自定义数据类型.<br>好处：能够合理管理内存,避免使用sql的麻烦, 更高效. 不需要我们手动去创建model类, 可以通过一些操作, 制动生成.</p>
</blockquote>
<a id="more"></a>
<h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><ol>
<li><strong>NSManagedObjectContext</strong> 临时数据库 向<strong>NSPersistentStoreCoordinator</strong> 持久化存储助理 发送一个key(model名字)</li>
<li><strong>NSPersistentStoreCoordinator</strong> 通过这个key 在 <strong>NSManagedObjectModel</strong> 数据模型中 找到这个model 对应的 表</li>
<li><strong>NSManagedObjectModel</strong> 将这个表名  返回给 <strong>NSPersistentStoreCoordinator</strong></li>
<li><strong>NSPersistentStoreCoordinator</strong> 通过 表名 找到 给表的 file 路径</li>
<li><strong> NSPersistentStoreCoordinator </strong> 将这个路径 返回给  <strong>NSManagedObjectContext</strong></li>
<li><strong>NSManagedObjectContext</strong> 对 数据进行 处理(增, 删 , 该, 查)</li>
<li><strong>NSManagedObjectContext </strong><br>保存数据 save</li>
</ol>
<h3 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h3><ol>
<li><b style="color:red">创建模型文件:</b>一个模型文件相当于一个数据库.<br><img src="http://upload-images.jianshu.io/upload_images/1975627-57ef108b72733513.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></li>
<li><b style="color:red">添加实体:</b> <em>一个实体相当于一个表.(点击下面add entity 添加表, 点击atttibutes的+号 添加属性)</em><br><img src="http://upload-images.jianshu.io/upload_images/1975627-036a03dec180ca9f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></li>
<li><b style="color:red">创建实体类:</b> 相当于模型类model.<br><img src="http://upload-images.jianshu.io/upload_images/1975627-0a11757c6d46ff45.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></li>
<li><p><b style="color:red">生成上下文, 来关联模型文件生成数据库</b><br>生成上下文时, 如果有多个数据库,且生成多个数据库文件时, 要使用不同的上下文进行操作.</p>
</li>
<li><p><b style="color:red">从数据库查询对象</b><br>  过滤查询, 排序查询, 分组查询等等</p>
</li>
<li><p><b style="color:red">更新数据</b><br>  前提: 先查询, 再修改数据</p>
</li>
<li><p><b style="color:red">删除数据</b><br>  前提: 先查询, 再删除数据</p>
</li>
<li><p><b style="color:red">多表关联</b><br>  在relationships添加与其他表的关联<br>  注意: 添加完关联后, 该表的实体类要删除重新生成<br><img src="http://upload-images.jianshu.io/upload_images/1975627-7b81372c0979bb12.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
</li>
<li><b style="color:red">多个数据库</b><br>  生成上下文时, 如果有多个数据库,且生成多个数据库文件时, 要使用不同的上下文进行操作.</li>
</ol>
<h3 id="构成"><a href="#构成" class="headerlink" title="构成"></a>构成</h3><p>(1)<code>NSManagedObjectContext</code>（被管理的数据上下文）<br>操作实际内容（操作持久层） 临时数据库<br>作用：插入数据，查询数据，删除数据</p>
<p>(2)<code>NSManagedObjectModel</code>（被管理的数据模型）<br>数据库所有表格或数据结构，包含各实体的定义信息    数据模型<br>作用：添加实体的属性，建立属性之间的关系<br>操作方法：视图编辑器，或代码</p>
<p>(3)<code>NSPersistentStoreCoordinator</code>（持久化存储助理）<br>相当于数据库的连接器<br>作用：设置数据存储的名字，位置，存储方式，和存储时机</p>
<p>(4)<code>NSManagedObject</code>（被管理的数据记录）<br>相当于数据库中的表格记录</p>
<p>(5)<code>NSFetchRequest</code>（获取数据的请求）<br>相当于查询语句  查询时 要建立请求对象</p>
<p>(6)<code>NSEntityDescription</code>（实体结构）<br>相当于表格结构</p>
<p>(7)后缀为.xcdatamodeld的包<br>里面是.xcdatamodel文件，用数据模型编辑器编辑 . 编译后为.momd或.mom文件</p>
<h3 id="SQLiteManager工具"><a href="#SQLiteManager工具" class="headerlink" title="SQLiteManager工具"></a>SQLiteManager工具</h3><ul>
<li><p><code>Z_PK</code> : 主键 <code>ZDEPART</code>: 外键<br><img src="http://upload-images.jianshu.io/upload_images/1975627-543672f4693585b0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
</li>
<li><p>打开CoreData的sql语句:<br>按照下图操作后, 使用CoreData时 会在控制台输出sql语句:<br><img src="http://upload-images.jianshu.io/upload_images/1975627-d50caf04845c5c6a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>添加-com.apple.CoreData.SQLDebug 和 1 两行<br>注意: 这两行的顺序如图所示, 不能调换.<br><img src="http://upload-images.jianshu.io/upload_images/1975627-8c49644ef29bb95f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
</li>
</ul>
<h3 id="SQLite-和-CoreData-的对比"><a href="#SQLite-和-CoreData-的对比" class="headerlink" title="SQLite 和 CoreData 的对比"></a>SQLite 和 CoreData 的对比</h3><blockquote>
<ol>
<li>sqlite是纯C语言存储方式.</li>
<li>CoreData是对sqlite的封装, 它的数据的保存直接使用对象, 不用再写sql语句.</li>
<li>性能方面: sqlite 优于 CoreData</li>
<li>什么时候使用sqlite 和 CoreData?<br>  如果数据库表关联比较复杂时, 三四张表都关联, 那就使用sqlite<br>  如果数据库表结构比较简单, 表之间没有关系, 使用CoreData</li>
</ol>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[iOS 数据存储 NSUserDefaults 的使用]]></title>
      <url>http://www.licheng.date/posts/NSUserDefaults.html</url>
      <content type="html"><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介:"></a>简介:</h3><blockquote>
<p>NSUserDefaults是一个单例，在整个程序中只有一个实例对象，他可以用于数据的永久保存，而且简单实用，这是它可以让数据自由传递的一个前提。</p>
</blockquote>
<a id="more"></a>
<blockquote>
<p>NSUserDefaults适合  存储轻量级  的本地数据  ，比如要保存一个登陆界面的数据，用户名、密码之类的，个人觉得使用NSUserDefaults是首选。下次再登陆的时候就可以直接从NSUserDefaults里面读取上次登陆的信息。就像读字符串一样，直接读取就可以了。</p>
<p>用NSUserDefaults存储的数据下次程序运行的时候依然存在 .它的数据存储在应用程序内置的一个plist文件里, 在/Library/Prefereces沙盒路径下.</p>
<p><strong>支持数据格式:</strong><br><br>NSNumber ( Integer、Float、Double )<br>NSString<br>NSArray<br>NSDictionary<br>BOOL类型<br>NSDate</p>
</blockquote>
<p><hr></p>
<h3 id="简单类型数据"><a href="#简单类型数据" class="headerlink" title="简单类型数据"></a>简单类型数据</h3><h4 id="读写-NSUserDefaults-中"><a href="#读写-NSUserDefaults-中" class="headerlink" title="读写 NSUserDefaults 中:"></a>读写 NSUserDefaults 中:</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">// 1. 创建NSUserDefaults单例:</span></div><div class="line"><span class="built_in">NSUserDefaults</span> *defaults = [<span class="built_in">NSUserDefaults</span> standardUserDefaults];</div><div class="line"></div><div class="line"><span class="comment">// 2. 数据写入:</span></div><div class="line">  <span class="comment">// 通过 key 值 来存入 和 读取数据</span></div><div class="line">[defaults setInteger:<span class="number">23</span> forKey:<span class="string">@"myInteger"</span>];</div><div class="line">  <span class="comment">// 注意：对相同的Key赋值约等于一次覆盖，要保证每一个Key的唯一性</span></div><div class="line"></div><div class="line"><span class="comment">// 3. 将数据 立即存入到 磁盘:</span></div><div class="line">[defaults synchronize];</div><div class="line"></div><div class="line"><span class="comment">// 4. 通过key值 按照写入对应类型 读取数据 有返回值</span></div><div class="line"><span class="built_in">NSInteger</span> *myInteger = [defaults integerForKey:<span class="string">@"myInteger"</span>];</div></pre></td></tr></table></figure>
<h4 id="注意"><a href="#注意" class="headerlink" title="注意:"></a>注意:</h4><p>NSUserDefaults 存储的对象全是不可变的（这一点非常关键，弄错的话程序会出bug），例如，如果我想要存储一个 NSMutableArray 对象，我必须先创建一个不可变数组（NSArray）再将它存入NSUserDefaults中去，代码如下：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSMutableArray</span> *mutableArray = [<span class="built_in">NSMutableArray</span> arrayWithObjects:<span class="string">@"123"</span>,<span class="string">@"234"</span>, <span class="literal">nil</span>];</div><div class="line"><span class="built_in">NSArray</span> * array = [<span class="built_in">NSArray</span> arrayWithArray:mutableArray];</div><div class="line"><span class="built_in">NSUserDefaults</span> *user = [<span class="built_in">NSUserDefaults</span> standardUserDefaults];</div><div class="line">[user setObject:array forKey:<span class="string">@"记住存放的一定是不可变的"</span>];</div></pre></td></tr></table></figure>
<p>取出数据是一样的，想要用NSUserDefaults中的数据给可变数组赋值, 先给出一个错误的写法：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*---------错误的赋值方法-----------*/</span></div><div class="line"><span class="built_in">NSUserDefaults</span> *user = [<span class="built_in">NSUserDefaults</span> standardUserDefaults];</div><div class="line"><span class="comment">//这样写后，mutableArray 就变成了不可变数组了，如果你要在数组中添加或删除数据就会出现bug</span></div><div class="line"><span class="built_in">NSMutableArray</span> *mutableArray = [user objectForKey:<span class="string">@"记住存放的一定是不可变的"</span>];</div></pre></td></tr></table></figure>
<p>正确的写法：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">  <span class="comment">/*--------正确的赋值方法----------*/</span></div><div class="line">  <span class="built_in">NSUserDefaults</span> *user = [<span class="built_in">NSUserDefaults</span> standardUserDefaults];</div><div class="line"></div><div class="line">  <span class="built_in">NSMutableArray</span> *mutableArray = [<span class="built_in">NSMutableArray</span></div><div class="line">arrayWithArray:[user objectForKey:<span class="string">@"记住存放的一定是不可变的"</span>]];</div></pre></td></tr></table></figure>
<p><hr></p>
<h3 id="自定义类型数据"><a href="#自定义类型数据" class="headerlink" title="自定义类型数据"></a>自定义类型数据</h3><p>使用NSKeyedArchiver 对数据进行归档 反归档.</p>
<h4 id="将自定义类型转换为NSData类型"><a href="#将自定义类型转换为NSData类型" class="headerlink" title="将自定义类型转换为NSData类型:"></a>将自定义类型转换为NSData类型:</h4><blockquote>
<p>当数据重复而且多的时候（例如想存储全班同学的学号，姓名，性别（这个数据量可能太大了 ）），如果不用SQLite 存储 （多数据最好还是用这个），可以选择使用归档，再将文件写入本地，但是这种方式和 NSUserDefaults 比起来麻烦多了（因为NSFileManage 本来就挺复杂） ，但是问题是，NSUserDefaults 本身不支持自定义对象的存储，不过它支持NSData的类型，可以转化为 NSdata 类型 。</p>
</blockquote>
<p>我们先建立一个叫Student 的类，这个类里有三个属性(姓名, 年龄, 性别）,代码如下：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Student</span> : <span class="title">NSObject</span></span></div><div class="line"></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSString</span> *name;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSString</span> *sex;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">NSInteger</span> age;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p>我们要做的就是将Student类型变成NSData类型 ，那么就必须实现<strong><em>归档</em></strong>：<br>这里要实现 在.h 文件中申明 NSCoding 协议，再 在 .m 中实现 <code>encodeWithCoder</code> 方法 和<br><code>initWithCoder</code> 方法就可以了 ：<br>.h 中修改,代码如下 ：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Student</span> : <span class="title">NSObject</span>  &lt;<span class="title">NSCoding</span>&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSString</span> *name;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSString</span> *sex;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">NSInteger</span> age;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p>.m中加入代码 ：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#import <span class="meta-string">"Student.h"</span></span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Student</span></span></div><div class="line"><span class="comment">// 归档</span></div><div class="line">-(<span class="keyword">void</span>)encodeWithCoder:(<span class="built_in">NSCoder</span> *)aCoder&#123;</div><div class="line">    </div><div class="line">    [aCoder encodeObject:<span class="keyword">self</span>.name forKey:<span class="string">@"name"</span>];</div><div class="line">    [aCoder encodeObject:<span class="keyword">self</span>.age forKey:<span class="string">@"age"</span>];</div><div class="line">    [aCoder encodeObject:<span class="keyword">self</span>.sex forKey:<span class="string">@"sex"</span>];</div><div class="line">&#125;</div><div class="line"><span class="comment">// 反归档</span></div><div class="line">-(<span class="keyword">instancetype</span>)initWithCoder:(<span class="built_in">NSCoder</span> *)aDecoder&#123;</div><div class="line">    </div><div class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>) &#123;</div><div class="line">        <span class="keyword">self</span>.name = [aDecoder decodeObjectForKey:<span class="string">@"name"</span>];</div><div class="line">        <span class="keyword">self</span>.age = [aDecoder decodeObjectForKey:<span class="string">@"age"</span>];</div><div class="line">        <span class="keyword">self</span>.sex = [aDecoder decodeObjectForKey:<span class="string">@"sex"</span>];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p>这样做就可以将自定义类型转变为NSData类型了,  下来进行 写入 和 读取.</p>
<h4 id="写入数据"><a href="#写入数据" class="headerlink" title="写入数据:"></a>写入数据:</h4><p>如果要存储全班同学的信息，我们可以建一个NSMutableArray 来存放全班同学的信息（里面存储的全是NSData对象）在需要存储的地方加入代码：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 首先，要建立一个可变数组来存储 NSDate对象</span></div><div class="line">Student *student = [[Student alloc] init];</div><div class="line"></div><div class="line"><span class="comment">// 下面进行的是对student对象的 name, age, sex 赋值</span></div><div class="line">student.name = <span class="string">@"张三"</span>;</div><div class="line">student.age = <span class="string">@"20"</span>;</div><div class="line">student.sex = <span class="string">@"男"</span>;</div><div class="line"></div><div class="line"><span class="comment">// 将student对象转换成为NSData类型</span></div><div class="line"><span class="built_in">NSData</span> *data = [<span class="built_in">NSKeyedArchiver</span> archivedDataWithRootObject:student];</div><div class="line"></div><div class="line"><span class="comment">// 保存学生信息</span></div><div class="line"><span class="built_in">NSUserDefaults</span> *user = [<span class="built_in">NSUserDefaults</span> standardUserDefaults];</div><div class="line">[user setObject:data forKey:<span class="string">@"oneStudent"</span>];</div></pre></td></tr></table></figure>
<p>如果你想存储全班同学的信息，你还要用一个for循环将data 放入 dataArray中.</p>
<h4 id="读取数据"><a href="#读取数据" class="headerlink" title="读取数据:"></a>读取数据:</h4><p>例如还原一个学生的数据：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSUserDefaults</span> *user = [<span class="built_in">NSUserDefaults</span> standardUserDefaults];</div><div class="line"></div><div class="line"><span class="comment">// 读取data数据</span></div><div class="line"><span class="built_in">NSData</span> *data = [user objectForKey:<span class="string">@"oneStudent"</span>];</div><div class="line"></div><div class="line"><span class="comment">// 将data类型转换成student类型</span></div><div class="line">Student *student = [<span class="built_in">NSKeyedUnarchiver</span> unarchiveObjectWithData:data];</div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, student.name);</div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, student.age);</div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, student.sex);</div></pre></td></tr></table></figure>
<hr>

<p>总之，NSUserDefaults 在我们编写代码中是最常用的一个永久保存数据的方法，也是最简单的。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[iOS 从经典问题来看 Copy 方法]]></title>
      <url>http://www.licheng.date/posts/Copy%E6%93%8D%E4%BD%9C.html</url>
      <content type="html"><![CDATA[<p>在初学 iOS 的时候，可能会被灌输这么一个常识，切记: <strong>NSString 的 property 的修饰变量要写作 copy ，而不是 strong。</strong>那么这是为什么？</p>
<blockquote>
<p><strong>经典面试题：为什么 NSString 类型成员变量的修饰属性用 copy 而不是 strong (或 retain ) ?</strong></p>
</blockquote>
<a id="more"></a>
<h2 id="Copy操作"><a href="#Copy操作" class="headerlink" title="Copy操作"></a>Copy操作</h2><p>###测试1:<br>模拟一个程序设计错误的场景。有一个叫做 Person 的 Class，其中它拥有一个 NSString 类型的 <code>s_name</code> 属性（代表 name 是 strong），我们想给一个对象的<code>s_name</code> 赋值，并且之前的赋值变量还想重复使用到其他场景。所以，我们在引入这个 Class 的 ViewController 进行如下操作：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)test1 &#123;</div><div class="line">    <span class="keyword">self</span>.one = [[Person alloc] init];</div><div class="line">    <span class="built_in">NSMutableString</span> *name = [<span class="built_in">NSMutableString</span> stringWithFormat:<span class="string">@"iOS"</span>];</div><div class="line">    <span class="keyword">self</span>.one.s_name = name;</div><div class="line">    </div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, <span class="keyword">self</span>.one.s_name);</div><div class="line">    </div><div class="line">    [name appendString:<span class="string">@" Source Probe"</span>];</div><div class="line">    </div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, <span class="keyword">self</span>.one.s_name);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果在 Person 这个 Class 中，我们的 <code>s_name</code> 的修饰属性是 <code>strong</code> 的话，会看到如下输出结果:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">2016-08-12 05:51:21.262 TestCopy[64714:20449045] iOS</div><div class="line">2016-08-12 05:51:21.262 TestCopy[64714:20449045] iOS Source Probe</div></pre></td></tr></table></figure>
<p>但是，我们操作的仅仅是对 <code>s_name</code>那个变量，为什么连属性当中的 <code>s_name</code> 也会被改变？对这段代码稍做修改，重新测试。</p>
<h3 id="测试2"><a href="#测试2" class="headerlink" title="测试2:"></a>测试2:</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)test2 &#123;</div><div class="line">    <span class="keyword">self</span>.one = [[Person alloc] init];</div><div class="line">    <span class="built_in">NSString</span> *name = [<span class="built_in">NSMutableString</span> stringWithFormat:<span class="string">@"iOS"</span>];</div><div class="line">    <span class="keyword">self</span>.one.s_name = name;</div><div class="line"></div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, <span class="keyword">self</span>.one.s_name);</div><div class="line"></div><div class="line">    name = <span class="string">@"iOS Source Probe"</span>;</div><div class="line"></div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, <span class="keyword">self</span>.one.s_name);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这一次我们看到了输出结果是正常的：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="number">2016</span><span class="number">-08</span><span class="number">-12</span> <span class="number">05</span>:<span class="number">56</span>:<span class="number">57.162</span> TestCopy[<span class="number">64842</span>:<span class="number">20459179</span>] iOS</div><div class="line"><span class="number">2016</span><span class="number">-08</span><span class="number">-12</span> <span class="number">05</span>:<span class="number">56</span>:<span class="number">57.162</span> TestCopy[<span class="number">64842</span>:<span class="number">20459179</span>] iOS</div></pre></td></tr></table></figure>
<h3 id="测试3"><a href="#测试3" class="headerlink" title="测试3:"></a>测试3:</h3><p>再来做第三个实验，我们换用 <code>copy</code> 类型的成员 <code>c_name</code>，来替换测试1中的 <code>s_name</code> ，查看一下输出结果:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">2016-08-12 06:03:40.226 TestCopy[64922:20479646] iOS</div><div class="line">2016-08-12 06:03:40.227 TestCopy[64922:20479646] iOS</div></pre></td></tr></table></figure>
<p>做过如上三个实验，或许你会知道对 property 使用 copy 修饰属性的原因了。也就是在一个特定场景下：</p>
<blockquote>
<p></p><p style="color:#990000"><strong>当我们通过一个 NSMutableString 对 NSString 变量进行赋值，如果 NSString 的 property 是 strong 类型的时候，就会随着 NSMutableString 类型的变量一起变化。</strong></p><p></p>
</blockquote>
<p>这个猜测是正确的, 但是为什么呢? 继续测试:</p>
<h3 id="测试4"><a href="#测试4" class="headerlink" title="测试4:"></a>测试4:</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)test4 &#123;</div><div class="line">    <span class="built_in">NSMutableString</span> *str = [<span class="built_in">NSMutableString</span> stringWithFormat:<span class="string">@"iOS"</span>];</div><div class="line">    </div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%p"</span>, str);</div><div class="line">    </div><div class="line">    <span class="built_in">NSString</span> *str_a = str;</div><div class="line">    </div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%p"</span>, str_a);</div><div class="line">    </div><div class="line">    <span class="built_in">NSString</span> *str_b = [str <span class="keyword">copy</span>];</div><div class="line">    </div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%p"</span>, str_b);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>输出地址后，我们发现以下结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">2016-08-12 06:15:45.169 TestCopy[65230:20515110] 0x7faf28429e70</div><div class="line">2016-08-12 06:15:45.170 TestCopy[65230:20515110] 0x7faf28429e70</div><div class="line">2016-08-12 06:15:45.170 TestCopy[65230:20515110] 0xa00000000534f693</div></pre></td></tr></table></figure>
<p>发现当令 NSString 对象指针指向一个 NSMutableString 类型变量通过 copy 方法返回的对象，则会对其进行<strong>深复制</strong>。这也就是我们一直所说的在一个 Class 的成员是 NSString 类型的时候，修饰属性应该使用 copy ，其实就是在使用 mutable 对象进行赋值的时候，防止 mutable 对象的改变从而影响成员变量。从 MRC 的角度来看待修饰属性，若一个属性的关键字为 retain （可等同于 strong ），则在进行指针的指向修改时，如上面的<code>self.one.name = str</code>，其实是执行了<code>self.one.name = [str retain]</code>，而 copy 类型的属性则会执行<code>self.one.name = [str copy]</code>。</p>
<p>而在 Test 2 中，我们的实验是将一个 NSString 对象指向另外一个 NSString 对象，那么如果前者是 copy 的成员，还会进行<strong>深复制</strong>吗？进行下面的 Test 5，我们令 c_name 的修饰变量为 copy。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[iOS开发 关于pch文件的创建与配置]]></title>
      <url>http://www.licheng.date/posts/pch%E7%9A%84%E5%88%9B%E5%BB%BA.html</url>
      <content type="html"><![CDATA[<h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><blockquote>
<p>在Xcode6之前, 创建一个新工程 Xcode会在 Supporting files 文件夹下面自动创建一个名为“工程名-Prefix.pch”文件, 也是一个头文件, pch头文件的内容能被项目中的其他所有源文件共享和访问。是一个预编译文件。<br>Xcode6以后创建项目时, 不再会自动生成pch文件, 需要我们手动创建.</p>
</blockquote>
<a id="more"></a>
<hr>
<h3 id="pch的作用"><a href="#pch的作用" class="headerlink" title="pch的作用"></a>pch的作用</h3><ul>
<li>存放一些全局的宏定义(整个项目中都用得上的宏);</li>
<li>用来包含一些大多数类所用到的头文件(整个项目中都用得上的头文件);</li>
<li>设置自动打开或者关闭日志输出功能;</li>
</ul>
<h3 id="在Xcode6以后的版本中添加pch文件"><a href="#在Xcode6以后的版本中添加pch文件" class="headerlink" title="在Xcode6以后的版本中添加pch文件"></a>在Xcode6以后的版本中添加pch文件</h3><ol>
<li>command+N, 打开新建文件窗口: iOS -&gt; Other -&gt; PCH File, 创建一个pch文件: <img src="http://upload-images.jianshu.io/upload_images/1975627-a1ba4bb86439eb2d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></li>
<li>在工程的 Targets 里边的 Building Setting 中搜索 Prefix Header, 然后把 Precompile Prefix Header 右边的NO改为Yes, 预编译后的pch文件会被缓存起来, 可以提高编译速度, 如图所示：<br><img src="http://upload-images.jianshu.io/upload_images/1975627-33c0f71c97041e3b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></li>
<li>设置pch文件的路径, $(SRCROOT)代表工程的根目录，然后后边还要加上pch在当前项目的路径，所以完整的pch文件的路径就是：<code>$(SRCROOT)/PchDemo/Tools/PrefixHeader.pch</code> ; 知道了pch文件的目录, 接下来我们就可以设置了, 在工程的 Targets 里边的 Building Setting 中搜索 Prefix Header, 找到 Prefix Header 属性, 双击后面空白处, 将pch的路径填写到里面, 如图所示：<br><img src="http://upload-images.jianshu.io/upload_images/1975627-95572e917b302a33.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></li>
<li>command + B 编译一下, 如果没有报错, 说明pch文件的创建和配置成功了.</li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[iOS 遍历集合(NSArray，NSDictionary、NSSet)方法总结]]></title>
      <url>http://www.licheng.date/posts/%E9%9B%86%E5%90%88%E9%81%8D%E5%8E%86.html</url>
      <content type="html"><![CDATA[<blockquote>
<p>想到循环遍历数组、字典这些常见的集合，大家脑子里第一反应就是for循环和快速遍历，并津津乐道的传承使用着这些方法，这些已经足够满足开发中所有类似的需求，似乎没有什么需要总结的，其实不然，不信往下看，知道的大神就不要浪费时间了。</p>
</blockquote>
<a id="more"></a>
<hr>
<h3 id="第一种方式：for循环"><a href="#第一种方式：for循环" class="headerlink" title="第一种方式：for循环"></a>第一种方式：for循环</h3><p>Objective-C是基于C语言的，自然可以使用for循环.</p>
<h4 id="遍历数组："><a href="#遍历数组：" class="headerlink" title="遍历数组："></a>遍历数组：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">NSArray *iosArray = @[@&quot;L&quot;, @&quot;O&quot;, @&quot;V&quot;, @&quot;E&quot;, @&quot;I&quot;, @&quot;O&quot;, @&quot;S&quot;];</div><div class="line">for (int i = 0; i &lt; iosArray.count; i++) &#123;</div><div class="line">	//处理数组中数据</div><div class="line">	NSLog(@&quot;%@&quot;, iosArray[i]);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>遍历数组很简单没问题，下面遍历字典.</p>
<h4 id="遍历字典："><a href="#遍历字典：" class="headerlink" title="遍历字典："></a>遍历字典：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">NSDictionary *dict = @&#123;@&quot;1&quot;:@&quot;11&quot;, @&quot;2&quot;:@&quot;22&quot;, @&quot;3&quot;:@&quot;33&quot;&#125;;</div><div class="line">NSArray *keysArray = [dict allKeys];</div><div class="line">for (int i = 0; i &lt; keysArray.count; i++) &#123;</div><div class="line">	//根据键值处理字典中的每一项</div><div class="line">	NSString *key = keysArray[i];</div><div class="line">	NSString *value = dict[key];</div><div class="line">	NSLog(@&quot;%@&quot;, value);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们知道字典和set是无序的，所以我们无法根据特定的整数下标来直接访问其中的值，于是需要先获取字典中的键或者set中的所有对象，这样就可以在获取到的有序数组上进行遍历了。然而创建数组是要额外的开销的，还会多创建出一个数组对象，他会保留collection中的所有对象，占用了内存。</p>
<h4 id="总结优缺点："><a href="#总结优缺点：" class="headerlink" title="总结优缺点："></a>总结优缺点：</h4><p>优点：被广泛使用，容易接受，操作简单；<br><br>缺点：遍历字典和set是比较繁琐，会占用比较多的系统资源。</p>
<hr>
<h3 id="第二种方式：NSEnumerator"><a href="#第二种方式：NSEnumerator" class="headerlink" title="第二种方式：NSEnumerator"></a>第二种方式：NSEnumerator</h3><p>NSEnumerator是一个抽象基类，其中定义了2个方法，使其子类实现：</p>
<p><code>- (nullable ObjectType)nextObject;</code></p>
<p><code>@property (readonly, copy) NSArray*allObjects;</code></p>
<p>其中<code>nextObject</code>是关键方法，它返回枚举里的下一个对象。每次调用改方法其，其内部结构都会更新，使得下一次调用方法时能返回下一个对象。等到枚举中全部的对象都已经返回之后，在调用就会返回<code>nil</code>，表示达到了枚举的末端。</p>
<p><code>Foundation</code>框架中的<code>collection</code>都实现了这种遍历方式，例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">NSArray *iosArray = @[@&quot;L&quot;, @&quot;O&quot;, @&quot;V&quot;, @&quot;E&quot;, @&quot;I&quot;, @&quot;O&quot;, @&quot;S&quot;];</div><div class="line">NSEnumerator *enumerator = [iosArray objectEnumerator];//正向遍历</div><div class="line">NSEnumerator *enumerator = [iosArray reverseObjectEnumerator];//反向遍历</div><div class="line">id object;</div><div class="line">while ((object = [enumerator nextObject]) != nil) &#123;</div><div class="line">	//处理枚举器中的数据</div><div class="line">	NSLog(@&quot;%@&quot;, object);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>字典和set实现的方式相似，不同的是字典中有key和value，要根据具体的key取出value。同时提供了正向遍历和反向遍历。</p>
<h4 id="总结优缺点：-1"><a href="#总结优缺点：-1" class="headerlink" title="总结优缺点："></a>总结优缺点：</h4><p>优点：<br>代码更易读，不需要定义额外的数组；<br><br>缺点：<br>1、无法直接获取遍历操作的下标，需要另外声明变量记录；<br>      <br>2、需要自行创建NSEnumerator对象，稍显麻烦。</p>
<hr>
<h3 id="第三种方式：快速遍历"><a href="#第三种方式：快速遍历" class="headerlink" title="第三种方式：快速遍历"></a>第三种方式：快速遍历</h3><p>Objective-C 2.0引入了快速遍历这一功能，快速遍历与NSEnumerator差不多，然而语法更为简洁，它为for循环开设了in关键字，简化了遍历collection所需的语法，例如:</p>
<h4 id="遍历数组"><a href="#遍历数组" class="headerlink" title="遍历数组"></a>遍历数组</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">NSArray *iosArray = @[@&quot;L&quot;, @&quot;O&quot;, @&quot;V&quot;, @&quot;E&quot;, @&quot;I&quot;, @&quot;O&quot;, @&quot;S&quot;];</div><div class="line">for (NSString *obj in iosArray) &#123;</div><div class="line">	//处理数组中的数据</div><div class="line">	NSLog(@&quot;%@&quot;, obj);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="遍历字典"><a href="#遍历字典" class="headerlink" title="遍历字典"></a>遍历字典</h4><p>也同样简单：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">NSDictionary *dict = @&#123;@&quot;1&quot;:@&quot;11&quot;, @&quot;2&quot;:@&quot;22&quot;, @&quot;3&quot;:@&quot;33&quot;&#125;;</div><div class="line">for (NSString *key in dict) &#123;</div><div class="line">	//处理字典的键值</div><div class="line">	NSString *value = dict[key];</div><div class="line">	NSLog(@&quot;%@&quot;, value);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>反向遍历可以使用:<br><code>for (NSString *obj in [iosArray reverseObjectEnumerator])</code></p>
<p>####总结优缺点</p>
<p>优点：<br>语法简洁，使用方便，效率高；<br><br>缺点：<br><br>1、无法方便获取当前遍历的下标；<br>2、无法在遍历过程中修改被遍历的collection，否则会导致崩溃。</p>
<hr>
<h3 id="第四种方式：基于块的遍历方式"><a href="#第四种方式：基于块的遍历方式" class="headerlink" title="第四种方式：基于块的遍历方式"></a>第四种方式：基于块的遍历方式</h3><p><em><b>这才是本文的重点，也是笔者极力推荐使用的方法，苹果封装了如此高效、优雅、易用的一套接口不用多么浪费。</b></em></p>
<h4 id="遍历数组-1"><a href="#遍历数组-1" class="headerlink" title="遍历数组"></a>遍历数组</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">NSArray *iosArray = @[@&quot;L&quot;, @&quot;O&quot;, @&quot;V&quot;, @&quot;E&quot;, @&quot;I&quot;, @&quot;O&quot;, @&quot;S&quot;];</div><div class="line">[iosArray enumerateObjectsUsingBlock:^(id  _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) &#123;</div><div class="line">	NSLog(@&quot;%@&quot;, obj);</div><div class="line">	if ([obj isEqualToString:@&quot;E&quot;]) &#123;</div><div class="line">		*stop = YES;</div><div class="line">	&#125;</div><div class="line">&#125;];</div></pre></td></tr></table></figure>
<p>参数说明：<br><br><code>obj</code>表示数组中的元素;<br><br><code>idx</code>表示元素的下标;<br><br><code>stop</code>可以控制遍历何时停止，在需要停止时令<code>*stop = YES</code>即可（不要忘记前面的*）。</p>
<p>这种方法清晰明了，数组元素，下标都可直接获取，就连何时停止都很容易实现，break都可以退休了，遍历字典也同样简单。</p>
<p>####遍历字典<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">NSDictionary *dict = @&#123;@&quot;1&quot;:@&quot;11&quot;, @&quot;2&quot;:@&quot;22&quot;, @&quot;3&quot;:@&quot;33&quot;&#125;;</div><div class="line">[dict enumerateKeysAndObjectsUsingBlock:^(id  _Nonnull key, id  _Nonnull obj, BOOL * _Nonnull stop) &#123;</div><div class="line">	NSLog(@&quot;%@&quot;, obj);</div><div class="line">	if ([obj isEqualToString:@&quot;22&quot;]) &#123;</div><div class="line">	*stop = YES;</div><div class="line">	&#125;</div><div class="line">&#125;];</div></pre></td></tr></table></figure></p>
<p>你没有看错，就是这么简单，block直接把字典的key和value都给我们了，再也不用书写直白而繁琐的代码了。</p>
<p>注意：</p>
<blockquote>
<p>若已知collection里对象的数据类型，可以修改块签名，知道对象的精确类型后，编译器就可以检测开发者是否调用了该对象所不具有的方法，并在发现问题时报错。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">NSDictionary *dict = @&#123;@&quot;1&quot;:@&quot;11&quot;, @&quot;2&quot;:@&quot;22&quot;, @&quot;3&quot;:@&quot;33&quot;&#125;;</div><div class="line">[dict enumerateKeysAndObjectsUsingBlock:^(NSString *key, NSString *obj, BOOL * _Nonnull stop) &#123;</div><div class="line">	NSLog(@&quot;%@&quot;, obj);</div><div class="line">	if ([obj isEqualToString:@&quot;22&quot;]) &#123;</div><div class="line">		*stop = YES;</div><div class="line">	&#125;</div><div class="line">&#125;];</div></pre></td></tr></table></figure>
<p>如代码，直接把key和value的类型修改成NSString类型。</p>
<h4 id="反向遍历"><a href="#反向遍历" class="headerlink" title="反向遍历"></a>反向遍历</h4><p>反向遍历也同样方便，调用另外一个方法即可：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">NSArray *iosArray = @[@&quot;L&quot;, @&quot;O&quot;, @&quot;V&quot;, @&quot;E&quot;, @&quot;I&quot;, @&quot;O&quot;, @&quot;S&quot;];</div><div class="line">[iosArray enumerateObjectsWithOptions:NSEnumerationReverse usingBlock:^(NSString *obj, NSUInteger idx, BOOL * _Nonnull stop) &#123;</div><div class="line">	NSLog(@&quot;%@&quot;, obj);</div><div class="line">	if ([obj isEqualToString:@&quot;E&quot;]) &#123;</div><div class="line">		*stop = YES;</div><div class="line">	&#125;</div><div class="line">&#125;];</div></pre></td></tr></table></figure>
<p>这个方法相对于正向遍历多了一个枚举类型的参数<code>NSEnumerationReverse</code>，打开这个选项就可以反向遍历了。</p>
<h4 id="并发遍历"><a href="#并发遍历" class="headerlink" title="并发遍历"></a>并发遍历</h4><p>顺着这个枚举类型的参数，就会引出块枚举的另一大优势：并发遍历，参数是：<code>NSEnumerationConcurrent</code>，也就是可以同时遍历<code>collection</code>中的几个元素，具体数量根据系统资源而定。这样会充分利用系统资源，高效快捷的完成collection的遍历，系统底层会通过GCD来处理并发事宜，开发者不需要担心内存和线程，其他方式若要实现高效的并发遍历十分有难度。通过块枚举遍历，改变collection并不会引起崩溃，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">NSArray *iosArray = @[@&quot;L&quot;, @&quot;O&quot;, @&quot;V&quot;, @&quot;E&quot;, @&quot;I&quot;, @&quot;O&quot;, @&quot;S&quot;];</div><div class="line">NSMutableArray *iosMutableArray = [NSMutableArray arrayWithArray:iosArray];</div><div class="line">[iosMutableArray enumerateObjectsWithOptions:NSEnumerationConcurrent usingBlock:^(NSString *obj, NSUInteger idx, BOOL * _Nonnull stop) &#123;</div><div class="line">	obj = [NSString stringWithFormat:@&quot;_%@&quot;, obj];</div><div class="line">	[iosMutableArray replaceObjectAtIndex:idx withObject:obj];</div><div class="line">	NSLog(@&quot;%@&quot;, obj);</div><div class="line">	if ([obj isEqualToString:@&quot;_I&quot;]) &#123;</div><div class="line">		*stop = YES;</div><div class="line">	&#125;</div><div class="line">&#125;];</div></pre></td></tr></table></figure>
<h4 id="优缺点总结"><a href="#优缺点总结" class="headerlink" title="优缺点总结"></a>优缺点总结</h4><p>优点：<br><br>1、可以完美实现for循环的所有功能；<br><br>2、可以方便获取集合中的每一项元素；<br><br>3、提供了循环遍历的参数，NSEnumerationReverse用来实现倒序循环。NSEnumerationConcurrent用来实现并发遍历，两个参数可以同时使用；<br><br>4、这种循环方式效率高，能够提升程序性能，开发者可以专注于业务逻辑，而不必担心内存和线程的问题；<br><br>5、当开启NSEnumerationConcurrent选项时，可以实现for循环和快速遍历无法轻易实现的并发循环功能，系统底层会通过GCD处理并发事宜，这样可以充分利用系统和硬件资源，达到最优的遍历效果；<br><br>6、可以修改块签名，当我们已经明确集合中的元素类型时，可以把默认的签名id类型修改成已知类型，比如常见的NSString，这样既可以节省系统资源开销，也可以防止误向对象发送不存在的方法是引起的崩溃。<br></p>
<p>缺点：<br><br>1、很多开发者不知道这种遍历方式；<br><br>2、这里使用了block，需要注意在block里容易引起的保留环问题，比如使用self调用方法时，把self转化成若引用即可打破保留环。如：<strong>weak `</strong>typeof(self)weakSelf = self<code>或者</code> __weak MyController *weakSelf = self;` 在block里使用weakSelf即可。</p>
<h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><p>使用基于块的遍历时是可以修改遍历的元素的，不会导致崩溃，但是如果要删除遍历的元素会导致后面的元素无法遍历而崩溃，解决办法有2种:<br><br>1、一种是复制一份原集合的副本，对副本进行操作，找出所要操作的元素后再处理原集合；<br><br>2、使用反向遍历，反向遍历删除元素后不会导致崩溃。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[iOS开发 APP跳转到相应的设置界面]]></title>
      <url>http://www.licheng.date/posts/%E8%B7%B3%E8%BD%AC%E8%AE%BE%E7%BD%AE%E7%95%8C%E9%9D%A2.html</url>
      <content type="html"><![CDATA[<h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><blockquote>
<p>在 iOS5.0 之后 apple 开放了 app 对 setting 的链接，用户可以通过 app 自己的方法实现 setting 的跳转。</p>
</blockquote>
<a id="more"></a>
<h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><p>其实方法也很简单主要是一下代码：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSURL</span>*url = [<span class="built_in">NSURL</span> URLWithString:<span class="string">@"prefs:root=参数"</span>];</div><div class="line"><span class="keyword">if</span> ([[<span class="built_in">UIApplication</span> sharedApplication] canOpenURL:url]</div><div class="line">&#123;</div><div class="line">    [[<span class="built_in">UIApplication</span> sharedApplication] openURL:url]; </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="常用参数"><a href="#常用参数" class="headerlink" title="常用参数:"></a>常用参数:</h3><table>
<thead>
<tr>
<th>英文</th>
<th style="text-align:center">参数</th>
<th style="text-align:right">中文</th>
</tr>
</thead>
<tbody>
<tr>
<td>About</td>
<td style="text-align:center">prefs : root=General&amp;path=About</td>
<td style="text-align:right"></td>
</tr>
<tr>
<td>Accessibility</td>
<td style="text-align:center">prefs:root=General&amp;path=ACCESSIBILITY</td>
<td style="text-align:right"></td>
</tr>
<tr>
<td>Airplane Mode On</td>
<td style="text-align:center">prefs:root=AIRPLANE_MODE</td>
<td style="text-align:right">飞行模式</td>
</tr>
<tr>
<td>Auto-Lock</td>
<td style="text-align:center">prefs:root=General&amp;path=AUTOLOCK</td>
<td style="text-align:right"></td>
</tr>
<tr>
<td>Brightness</td>
<td style="text-align:center">prefs:root=Brightness</td>
<td style="text-align:right"></td>
</tr>
<tr>
<td>Bluetooth</td>
<td style="text-align:center">prefs:root=General&amp;path=Bluetooth</td>
<td style="text-align:right">蓝牙</td>
</tr>
<tr>
<td>Date &amp; Time</td>
<td style="text-align:center">prefs:root=General&amp;path=DATE_AND_TIME</td>
<td style="text-align:right">日期</td>
</tr>
<tr>
<td>FaceTime</td>
<td style="text-align:center">prefs:root=FACETIME</td>
<td style="text-align:right">视频</td>
</tr>
<tr>
<td>General</td>
<td style="text-align:center">prefs:root=General</td>
<td style="text-align:right"></td>
</tr>
<tr>
<td>Keyboard</td>
<td style="text-align:center">prefs:root=General&amp;path=Keyboard</td>
<td style="text-align:right">键盘</td>
</tr>
<tr>
<td>iCloud</td>
<td style="text-align:center">prefs:root=CASTLE</td>
<td style="text-align:right">云</td>
</tr>
<tr>
<td>iCloud Storage &amp; Backup</td>
<td style="text-align:center">prefs:root=CASTLE&amp;path=STORAGE_AND_BACKUP</td>
<td style="text-align:right">云存储与备份</td>
</tr>
<tr>
<td>International</td>
<td style="text-align:center">prefs:root=General&amp;path=INTERNATIONAL</td>
<td style="text-align:right"></td>
</tr>
<tr>
<td>Location Services</td>
<td style="text-align:center">prefs:root=LOCATION_SERVICES</td>
<td style="text-align:right">位置服务</td>
</tr>
<tr>
<td>Music</td>
<td style="text-align:center">prefs:root=MUSIC</td>
<td style="text-align:right">音乐</td>
</tr>
<tr>
<td>Music Equalizer</td>
<td style="text-align:center">prefs:root=MUSIC&amp;path=EQ</td>
<td style="text-align:right">音乐均衡器</td>
</tr>
<tr>
<td>Music Volume Limit</td>
<td style="text-align:center">prefs:root=MUSIC&amp;path=VolumeLimit</td>
<td style="text-align:right">音乐音量限制</td>
</tr>
<tr>
<td>Network</td>
<td style="text-align:center">prefs:root=General&amp;path=Network</td>
<td style="text-align:right">网络</td>
</tr>
<tr>
<td>Nike + iPod</td>
<td style="text-align:center">prefs:root=NIKE_PLUS_IPOD</td>
<td style="text-align:right"></td>
</tr>
<tr>
<td>Notes</td>
<td style="text-align:center">prefs:root=NOTES</td>
<td style="text-align:right"></td>
</tr>
<tr>
<td>Notification</td>
<td style="text-align:center">prefs:root=NOTIFICATIONS_ID</td>
<td style="text-align:right">通知</td>
</tr>
<tr>
<td>Phone</td>
<td style="text-align:center">prefs:root=Phone</td>
<td style="text-align:right">电话</td>
</tr>
<tr>
<td>Photos</td>
<td style="text-align:center">prefs:root=Photos</td>
<td style="text-align:right">照片</td>
</tr>
<tr>
<td>Profile</td>
<td style="text-align:center">prefs:root=General&amp;path=ManagedConfigurationList</td>
<td style="text-align:right"></td>
</tr>
<tr>
<td>Reset</td>
<td style="text-align:center">prefs:root=General&amp;path=Reset</td>
<td style="text-align:right">重启</td>
</tr>
<tr>
<td>Safari</td>
<td style="text-align:center">prefs:root=Safari</td>
<td style="text-align:right">浏览器</td>
</tr>
<tr>
<td>Siri</td>
<td style="text-align:center">prefs:root=General&amp;path=Assistant</td>
<td style="text-align:right">语音控制</td>
</tr>
<tr>
<td>Sounds</td>
<td style="text-align:center">prefs:root=Sounds</td>
<td style="text-align:right">音效</td>
</tr>
<tr>
<td>Software Update</td>
<td style="text-align:center">prefs:root=General&amp;path=SOFTWARE_UPDATE_LINK</td>
<td style="text-align:right">软件更新</td>
</tr>
<tr>
<td>Store</td>
<td style="text-align:center">prefs:root=STORE</td>
<td style="text-align:right"></td>
</tr>
<tr>
<td>Twitter</td>
<td style="text-align:center">prefs:root=TWITTER</td>
<td style="text-align:right">博客</td>
</tr>
<tr>
<td>Usage</td>
<td style="text-align:center">prefs:root=General&amp;path=USAGE</td>
<td style="text-align:right"></td>
</tr>
<tr>
<td>VPN</td>
<td style="text-align:center">prefs:root=General&amp;path=Network/VPN</td>
<td style="text-align:right"></td>
</tr>
<tr>
<td>Wallpaper</td>
<td style="text-align:center">prefs:root=Wallpaper</td>
<td style="text-align:right">壁纸</td>
</tr>
<tr>
<td>Wi-Fi</td>
<td style="text-align:center">prefs:root=WIFI  INTERNET_TETHERING</td>
<td style="text-align:right">无线网</td>
</tr>
<tr>
<td>Internet_tethering</td>
<td style="text-align:center">prefs:root= INTERNET_TETHERING</td>
<td style="text-align:right">网络共享</td>
</tr>
</tbody>
</table>
<p>有一些没有查到是做什么的, 大家查到的可以在下方评论,谢谢!</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[iOS开发  给Label加下划线、中划线]]></title>
      <url>http://www.licheng.date/posts/%E7%BB%99Label%E5%8A%A0%E4%B8%8B%E5%88%92%E7%BA%BF%E3%80%81%E4%B8%AD%E5%88%92%E7%BA%BF.html</url>
      <content type="html"><![CDATA[<h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><blockquote>
<p>当我们在做一些购物类APP或者是商品展示类的APP时，我们经常会遇到某种商品打折优惠或者抢购的场景。并且为了吸引客户，商家一般把打折商品的现价和原价同时显示出来，进行对比，此时就出现了为展示原价的label添加中划线或者是下划线的需求。<br>我们参考一下驴妈妈的首页：</p>
</blockquote>
<a id="more"></a>
<p><img src="http://upload-images.jianshu.io/upload_images/1975627-b290ef9c1a340919.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="驴妈妈首页－中划线"><br>下面就直接上代码了：</p>
<h3 id="添加中划线"><a href="#添加中划线" class="headerlink" title="添加中划线"></a>添加中划线</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">UILabel</span> * strikeLabel = [[<span class="built_in">UILabel</span> alloc] initWithFrame:(<span class="built_in">CGRectMake</span>(<span class="number">10</span>, <span class="number">10</span>, <span class="number">50</span>, <span class="number">30</span>))];</div><div class="line"><span class="built_in">NSString</span> *textStr = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%@元"</span>, primeCost];</div><div class="line"></div><div class="line"><span class="comment">//中划线</span></div><div class="line"><span class="built_in">NSDictionary</span> *attribtDic = @&#123;<span class="built_in">NSStrikethroughStyleAttributeName</span>: [<span class="built_in">NSNumber</span> numberWithInteger:<span class="built_in">NSUnderlineStyleSingle</span>]&#125;;</div><div class="line"><span class="built_in">NSMutableAttributedString</span> *attribtStr = [[<span class="built_in">NSMutableAttributedString</span> alloc]initWithString:textStr attributes:attribtDic];</div><div class="line">      </div><div class="line"><span class="comment">// 赋值</span></div><div class="line">strikeLabel.attributedText = attribtStr;</div><div class="line"></div><div class="line">[<span class="keyword">self</span>.view addSubview:strikeLabel];</div></pre></td></tr></table></figure>
<h3 id="添加下划线"><a href="#添加下划线" class="headerlink" title="添加下划线"></a>添加下划线</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">UILabel</span> *underlineLabel = [[<span class="built_in">UILabel</span> alloc] initWithFrame:(<span class="built_in">CGRectMake</span>(<span class="number">10</span>, <span class="number">10</span>, <span class="number">50</span>, <span class="number">30</span>))];</div><div class="line"><span class="built_in">NSString</span> *textStr = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%@元"</span>, primeCost];</div><div class="line"></div><div class="line"><span class="comment">// 下划线</span></div><div class="line"><span class="built_in">NSDictionary</span> *attribtDic = @&#123;<span class="built_in">NSUnderlineStyleAttributeName</span>: [<span class="built_in">NSNumber</span> numberWithInteger:<span class="built_in">NSUnderlineStyleSingle</span>]&#125;;</div><div class="line"><span class="built_in">NSMutableAttributedString</span> *attribtStr = [[<span class="built_in">NSMutableAttributedString</span> alloc]initWithString:textStr attributes:attribtDic];</div><div class="line"></div><div class="line"><span class="comment">//赋值</span></div><div class="line">underlineLabel.attributedText = attribtStr;</div><div class="line"></div><div class="line">[<span class="keyword">self</span>.view addSubview:underlineLabel];</div></pre></td></tr></table></figure>
<p>效果如图所示：<br><img src="http://upload-images.jianshu.io/upload_images/1975627-7dfcab97f92a7872.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="效果图"></p>
]]></content>
    </entry>
    
  
  
</search>
